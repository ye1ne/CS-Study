## 목차
- [Process vs Thread](#process-vs-thread)
- [MultiThread 와 MultiProcess](#multithread-와-multiprocess)
- [Cache](#cache)
- [데드락(Deadlock)](#데드락-deadlock)
<br/><br/>

## Process vs Thread
### Process를 알아보자! 
#### 프로세스의 의미
- 실행중인 프로그램을 의미한다.
- 다수의 프로그램이 병행 수행될수 있는 오늘날에는 시분할 시스템(타임쉐어링)의 작업단위로 사용됨

#### 프로세스의 상태 변화

<center>
<img src="/images/processstatus.png">
 사진출처 : TOPCIT
 </center>

- 생성 -> 준비 : 스케줄러에 의해 프로세스가 호출됨.
- 준비 -> 살행 : 사전 정의된 스케줄링 알고리즘에 따라 프로세스가 CPU할당 받음. 해당과정을 **디스패치(dispatch)** 라고함
- 실행 -> 준비 : 더 높은 우선순위의 프로세스를 실행하거나, 자원할당시간 만료 후 준비상태로 다시 전환. 해당 과정을 **타임아웃(Timeout)** 이라 부름
- 실행 -> 대기 : 할당된 시간 이전 실행 중에 기타 입출력 요구, 페이지 교환, read, write 등으로 CPU를 다른 프로세서에 할당 양도한 상태. 즉, **Block 상태**
- 대기 -> 준비 : 위의 작업이 끝난 후, block 상태의 프로세스를 다시 준비상태로 돌려놓는다. **WakeUP 상태** 라고 부른다.

#### PCB (Process Control Block)
- 프로세스가 생성될때 고유의 PCB 생성, 프로세스 종료 후 PCB 제거
- PCB에는 프로그램 카운터, 프로세스 상태, PID(프로세스 식별 번호)등 존재

#### 프로세스 메모리 구조
- **Code(text)** : 실행할 프로그램의 코드 저장
- **Data** : 전연변수 및 정적변수 저장
	- 추가적으로 BSS(Block Stated Symbol) 영역 존재 : 초기화 되지 않은 전역변수가 저장됨
- **Stack** : 지역변수, 매개변수 등 잠시 사용되었다가 사라지는 데이터를 저장. 컬파일 타임에 크기가 결정된다.
- **Heap** : 동적 데이터 영역으로, 메모리 주소 값에 의해서 참조되고 사용되는 영역. 런타임에 크기가 결정된다. 
	- 예를들어) Stack에서 포인터 변수를 할당하면, 포인터가 가리키는 heap영역의 공간을 원하는 크기만큼 할당해 사용
	- Java 에서는 객체가 heap영역에 생성되고, Garbage Collection(GC)에 의해 정리
	- C에서는 malloc() 을 이용하여 할당


### Thread 를 알아보자!
#### 스레드의 의미
- 프로세스 내에서 실제로 작업을 실행하는 주체로 경량프로세스(lightweight process)라고도 부름
- 1개의 프로세스는 최소 1개의 스레드를 가진다.

#### 멀티 스레드
-  1개의 process에 2개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process) 라고부름
- 1개의 프로세스 안에 존재하는 스레드들은, 프로세스의 메모리 구조 중  **code, data, heap 영역은 공유**되며, 각 **스레드 별로 자신만의 Stack영역**을 갖는다
- 대표적인 예로 웹서버가 존재한다

### Context Switching을 알아보자!
#### 콘텍스트 스위칭이란
- 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 순위의 Task가 실행되도록 **새로운 Task의 상태 또는 레지스터의 값(Context)를 교체**하는 작업을 일컷는다
	- 이떄 Context는 프로세스의 PCB에 저장된다
- 콘텍스트 스위칭이 진행될때 해당 CPU는 아무런 일도 하지 못한다
- 따라서 콘텍스트 스위칭이 **잦아지면 오버헤드가 발생**한다.
- 콘텍스트 스위칭을 하는 주체 = OS 스케줄러 이다

[목차로 돌아가기](#목차)
<br/><br/>

## MultiThread 와 MultiProcess
### 멀티프로세스
#### 장점
- 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 끼치지 않음
  
#### 단점
- context 전환과 함께 각 프로세스의 memory도 전환됨. 즉 높은 context swtiching 비용 발생
- 상대적으로 많은 메모리 공간과 CPU 시간을 차지함

### 멀티스레드
#### 장점
- 적은 메모리 공간을 차지
- 스레드간 통신 시 Heap 영역을 이용하여 데이터를 전달하므로 통신 방법이 간단해짐
- code, data, heap 영역은 공유하기 때문에 context swtiching 비용이 상대적으로 적고 응답속도가 빠름
- 이로인해 시스템 처리량이 향상 됨

### 단점
- 동기화 문제 발생. 즉, 자원 공유 문제가 발생함
- 하나의 스레드에서 문제가 발생시 전체프로세스가 영향을 받는다.

[목차로 돌아가기](#목차)
<br/><br/>

## Cache
### 캐시 메모리(cache Memory)
#### 캐시 메모리란 ?
- 주기억장치에서 자주 사용하는 프로그램과 데이터를 저장해두고 속도를 빠르게 하는 메모리
- 속도가 빠른 장치와 느린 장치간의 병목 현상을 줄여주며, 메인 메모리와 CPU사이에 위치한다
- 캐시가 효율적으로 동작하기 위해서는 CPU가 참조할 정보에 대한 예측이 잘 되어야함
	- 즉, 캐시의 **적중률(Hit-rate)** 을 극대화 시켜야함
	- 이때 나오는 개념이 캐시의 지역성(Locality)


#### 캐시의 지역성(Locality)이란
- 데이터에 대한 접근이 시간적-공간적으로 가깝게 발생하는 것을 뜻함
- 이때 프로그램은 정보를 균일하게 참조하는 것이아니라, 어느 한 순간에 특정 부분을 집중 참조할 것이라는 전재 조건이 존재한다.
	- **시간지역성** : 최근에 참조된 데이터가 곧 다시 참조되는 특성
	- **공간지역성** : 최근에 참조된 데이터와 인접한 데이터가 참조될 가능성이 높은 특성


### 캐싱 라인(Caching Line)
#### 캐싱라인이 뭔가요?
- 캐시는 프로세서 가깝게 위치하며 자주 사용 되는 데이터들은 저장하는 것
- **목적 데이터를 바로 접근하여 출력**할 수 있어야 캐시가 의미가 있기때문에, 특정 자료구조를 사용하여 묶음으로 저장해놓는데, 이를 캐싱라인이라 칭함
- 즉, 캐시 메모리의 매핑 프로세스라고 말할 수 있음

#### 캐싱라인의 종류
**1. 직접 매핑(Direct Mapping)**
- 메모리 주소와 캐시의 순서를 일치 시켜 지정된 캐시 라인으로만 사상하는 방식으로
- 즉, 캐시 1에는 메모리 1~10번을, 캐시 2에는 메모리 11~20을 위치시키는것 
- 하지만 특정메모리 위치의 값을 자주 불러다 사용한다면 저장할 캐시 공간은 1개이므로 매번 캐시 교체가 일어남
- 즉 적중률과 성능이 낮지만 구현이 간단하고 쉬운 방법
**2. 연관 매핑(Associative Mapping)**
- 순서를 일치시키지 않고 필요한 메모리 값을 캐시의 어디든 편하게 저장한다
- 찾는 과정은 복잡하고 느리지만 필요한 캐시 위주로 저장하기에 적중률은 높다.
	- 캐시는 일반메모리보다 속도가 빠르므로 캐시의 검색량보다 적중률을 신경쓰는게 바람직함
**3. 직접 연관 매핑( Set Associative Mapping)**
- 연관매핑과 직접매핑을 합쳐놓은 방식. 
- 순서를 일치시키면서 일정 그룹을 두지만, 그 그룹내에서는 편하게 저장하는 방식이다.
- 블록화가 되어있어 검색에 조금더 효율적이며 적중률이 많이 떨어지지도 않는다.


[목차로 돌아가기](#목차)
<br/><br/>

## 데드락 (Deadlock)
### 데드락의 개념
#### 데드락 이란 ?
- 두개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해 다음 처리를 하지 못하는 상태
- '교착 상태'라고도 부르며, 시스템적으로 한정된 자원을 여러곳에서 사용할때 발생
- '외나무 양끝에서 두사람이 서로 비켜주기만 기다리는'것과 같음
- 아래의 예시를 참고해보자! 

<center>
<img src="/images/deadlock.png">
 사진출처 : geeksforgeeks
 </center>



 -  프로세스 1과 2가 리소스1과 2를 모두 얻어야 한다고 가정하자
- 프로세스1이 자원1을 얻은경우 프로세스2는 자원1을 얻을수없고, 프로세스2가 자원2를 가지고 있으므로 프로세스1은 자원2를 얻을 수 없다.
- 두 프로세스는 무한정 wait 상태에 빠지게되며, 이게바로 **DeadLock**


### 데드락의 발생 조건
|발생 조건|설명|
|---|---|
|상호배제(Mutual Exclusion) = Mutex| 한번에 하나의 프로세스만이 공유자원 사용가능한 상태
|점유하며 대기(Hold and Wait)| 프로세스들이 현재의 자원을 점유하며 다른 자원을 요구하는 상태|
|비선점(Non-Preemption)| 각 프로세스에 할당된 자원은 사용 완료될때까지 강제로 해제할 수 없는 상태|
|순환대기(Circular Wait)| 서로 다른 프로세스 간의 자원요구가 연속적으로 반복되는 상태|


### 데드락 처리방법

#### 예방(Prevention)
- 위의 4가지 발생 조건을 제거(막아)하여 미리 예방하는 방법
	- 상호배제 부정, 점유대기 부정, 비선점 부정, 순환대기 부정
#### 회피(Avoidance)
- 데드락 발생조건을 제거하지 않고 적절하게 피하는것
	- 은행원 알고리즘
		- 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데에서 착안
		- 프로세스의 자원 요구시, 자원할당 후에도 안정상태로 남아 있는지 사전에 검사하여 데드락을 회피
		- 안정상태를 유지하면 자원할당, 아니면 다른 프로세스들이 자원 해지까지 대기
#### 탐지(Detection)
- 데드락 발생을 허용하여 자원할당 그래프나 탐지 알고리즘 등을 통해 유발 프로세스를 찾아내 해결 
#### 회복(Recovery)
- 교착상태의 프로세스를 종료하거나 할당 자원을 해제함으로서 회복
	- 프로세스 종료
		1. 교착상태의 프로세스를 모두 중지
		2. 교착상태가 제거될때까지 한 프로세스씩 중지
	- 자원 선점. 즉, 데드락이 깨질때까지 프로세스로부터 자원을 계속 선점, 이들을 다른 프로세스에 주는 것
		1. 교착 상태의 프로세스가 점유하는 자원을 선점하여 다른 프로세스에 할당, 해당 프로세스를 일시 정지
		2. 우선순위가 낮은 프로세스를 위주로 프로세스 자원 선점


[목차로 돌아가기](#목차)